---
{"dg-publish":true,"permalink":"/00-课程笔记/Computer-Network/3-传输层/","title":"Note3- 传输层"}
---


# Note3- 传输层

## 知识点

#### 传输层的功能？

- 传输层协议为运行在不同主机上的应用**进程**之间提供了逻辑通信。而网络层提供的是主机之间的逻辑通信
- 复用和分用
- 对收到的报文进行差错检测
- 提供两种不同的传输协议，即面向连接的 TCP 协议和无连接的 UDP 协议
<!--ID: 1673063355452-->

#### 多路复用和多路分用

![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230107144917.png)

<!--ID: 1673075068796-->

#### 分用如何工作？

主机接收到 IP 数据报

- 每个数据报携带源 IP 地址、目的 IP 地址
- 每个数据报携带一个传输层的端
- 每个段携带源端口号和目的端口号
- ![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230107145144.png)
- 传输层协议提取 IP 地址和端口号信息，将段导向相应的 Socket
<!--ID: 1673075068804-->

#### 无连接分用和面向连接分用的区别？

- UDP 的 Socket 用二元组标识： (目的 IP 地址，目的端口号)，来自不同的源的数据可以被送到同一个目的套接字
- TCP 的 Socket 用四元组标识：(源 IP 地址，源端口号，目的 IP 地址，目的端口号)，来自不同的源的数据只能通过各自的 TCP 连接被送到不同的目的套接字，而这些套接字可使用相同端口号
<!--ID: 1673075068809-->

#### UDP 相比 TCP 的优点？

- 无需建立连接（减少延迟）
- 实现简单，无需维护连接状态
- 头部开销小
- 没有拥塞控制：应用可更好地控制发送时间和速率
<!--ID: 1673075553664-->

#### UDP 的报文段格式以及各字段功能？

![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230107151353.png)

- 源端口号和目的端口号实现了基本的多路分解。
- 长度字段表示整个 UDP 报文段的字节数，包括首部 + 数据载荷，最小值为 8。
- 检验和检测 UDP 数据报在传输过程中是否有差错。
<!--ID: 1673257671559-->

#### UDP 校验和字段如何计算？

发送方首先将校验和字段初始化为 0 ，然后把 UDP 段的内容视为 16-bit 整数，计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和。接收方以同样方式对报文段求和，应该得到全 1，否则表明有差错，丢弃。

<!--ID: 1673257671570-->

#### 停等协议 (Rdt 3.0) 的基本过程？

发送方：分组序号为 0/1 交替，每次发送一个编号为 i 的分组后便启动一个定时器。若收到 ACK(i) 则说明接收成功，发送下一个分组。若超时则重新发送。

接收方：若正确接收到分组 i，则回复 ACK(i)，否则回复 ACK(!i)

举例：

- 正常：![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230110115605.png)
- 丢包![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230110115640.png)
- 丢失 ACK：![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230110115714.png)
- 超时：![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230110115739.png)
<!--ID: 1673323246153-->

#### GBN 协议的基本过程？

发送方：当上层调用时，发送方检查发送窗口是否已满，若未满，则分配一个序号并发送。为窗口内最早的已发送但未被确认的分组设置一个定时器，若超时则重发所有已发送未确认分组。发送方接收到 ACK(i)，则表示 i 之前的所有分组都已被正确接收，窗口起点滑动到 i + 1（累积确认）

接收方：接收方没有缓存，假设等待接收分组 n ，如果接收到的分组不是 n（乱序到达），则丢弃这一分组。无论是否对其都要回复 ACK(m)，m 表示上一个正确接收到的分组序号。

举例：

![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230110143533.png)

<!--ID: 1673334262082-->

#### SR 协议的基本过程？

相对于 GBN 协议的改进：为接收方也设置了一个窗口缓存并逐个确认，从而可以接收乱序到达的分组，那么发送方就只需要重传超时未收到 ACK 的分组

发送方：为每一个分组都设置一个定时器，若某个分组超时则只重传这一个分组。当窗口的左端点分组得到确认后，则将窗口右移直至未确认分组处。

接收方：假设收到序号为 i 的分组，若 i 在 $[\text{rcv\_base},\text{rcv\_base}+N-1]$ 内就正确接收，将其缓存并回复 ACK(i)，如果 i 是接收窗口的基序号 $\text{rcv\_base}$，则将从该分组序号开始以后的连续已缓存的分组交付上层，接收窗口右移。若 i 在 $[\text{rcv\_base-N}, \text{rcv\_base-1}]$ 内，则说明这是因为之前接收方发送的 ACK 丢失发送方重发的冗余分组，此时也应回复 ACK(i)。其它情况都直接丢弃也不回复 ACK。

序号空间大小与窗口大小需满足：令 $N_s$ 为发送方窗口大小，$N_R$ 为接收方窗口大小，$k$ 为序号字段的位数，则应满足 $N_s+N_R \leq 2^k$

举例：![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230110145706.png)<!--ID: 1673334262093-->

#### TCP 的报文段格式以及各字段功能？

![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/20230110151014.png)

- 序列号 (sequece number)：占 4B。指段中第一个字节的序号。建立平均 TCP 连接时，双方随机选择序列号。
- 确认号 (ack number)：占 4B。希望接收到的下一个字节的序号。若确认号为 N，则表明到 N-1 为止的所有数据已正确收到（累积确认）。
- 确认位 ACK：ACK=1 时才说明确认号字段有效。
- 同步位 SYN：SYN=1，ACK=0 时，说明这是一个连接请求报文，SYN=1，ACK=1 时，说明这是一个连接接受报文
- 终止位 FIN：FIN=1 时，说明此报文段发送方的数据已发送完毕，要求释放连接。
<!--ID: 1673335436329-->

#### 如何设置 TCP 定时器的超时时间？

首要问题是估计 RTT。

- 设 SampleRTT 为段从发出去到收到 ACK 的时间。TCP 维持一个 SampleRTT 均值 EstimatedRTT，一旦获得一个新的 SampleRTT，就更新 EstimatedRTT：$\text{EstimatedRTT}=(1-\alpha)\, \text{EstimatedRTT}+\alpha \, \text{SampleRTT}$。
- 同时定义 SampleRTT 偏离 EstimatedRTT 程度 $\text{DevRTT}=(1-\beta)\, \text{DevRTT}+\beta \, | \text{SampleRTT}-\text{EstimatedRTT} |$
- 则超时时间间隔设置为 $\text{TimeoutInterval}=\text{EstimatedRTT}+4\, \text{DevRTT}$
<!--ID: 1673336537142-->

#### TCP 的快速重传机制是什么？

如果发送方收到对同一个数据的 3 个冗余 ACK 时，则假定该数据之后的段已经丢失，在定时器超时之前即重传。

<!--ID: 1673336897515-->

#### TCP 建立连接过程？

三次握手：

1. 客户端随机选择初始序号 client_isn，发送一个不带有效数据的特殊报文段，该段的 SYN=1
2. 服务端收到后为连接分配缓存，随机选择初始编号 server_isn，并向客户端发送一个不含有效数据的允许连接的报文段，该段 SYN=1，确认号字段设置为 client_isn+1
3. 客户收到后为连接分配缓存，向服务器发送 SYN=0，确认号为 server_isn+1，序号为 client_isn+1 的可携带数据的报文段
<!--ID: 1673339235897-->

#### TCP 关闭连接过程？

四次挥手：

1. A 数据传输完毕需要断开连接时向其 TCP 发出连接释放报文段（FIN = 1，序号 seq = u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1 状态，等待 B 的确认。
2. B 收到连接释放报文段后即发出确认报文段（ACK=1，确认号 u+1，序号 seq=v），B 进入 CLOSE-WAIT 关闭等待状态，此时的 TCP 处于半关闭状态，A 到 B 的连接释放。而 A 收到 B 的确认后，进入 FIN-WAIT-2 状态，等待 B 发出的连接释放报文段。B 此时可能仍然由数据要传输。
3. 当 B 数据传输完毕后，B 发出连接释放报文段（FIN = 1，ACK = 1，序号 seq = w，确认号 u+1），B 进入 LAST-ACK（最后确认）状态，等待 A 的最后确认。
4. A 收到 B 的连接释放报文段后，对此发出确认报文段（ACK = 1，seq=u+1，ack=w+1），A 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，A 才进入 CLOSED 状态。
<!--ID: 1673339235906-->

#### TCP Reno 拥塞控制的基本原理？

初始设置拥塞窗口 cwnd=1

- cwnd < sshresh 时，使用慢启动算法，每个 RTT 将 cwnd 翻倍
- cwnd > sshresh 时，使用拥塞避免算法，每个 RTT 将 cwnd 加 1
- 当收到三个冗余 ACK 时，将 sshresh 设置为 cwnd/2，cwnd 设置为 sshresh
- 当出现超时时，将 sshresh 设置为 cwnd/2，将 cwnd 设置为 1
<!--ID: 1673342619604-->

## MOOC 习题

> （同书 P37 题）假设主机 A 向主机 B 发送 5 个连续的报文段，主机 B 对每个报文段进行确认，其中第二个报文段丢失，其余报文段以及重传的第二个报文段均被主机 B 正确接收，主机 A 正确接收所有 ACK 报文段；报文段从 1 开始依次连续编号（即 1、2、3……），主机 A 的超时时间足够长。请回答下列问题：
> 1. 如果分别采用 GBN、SR 和 TCP 协议，则对应这三个协议，主机 A 分别总共发了多少个报文段？主机 B 分别总共发送了多少个 ACK？它们的序号是什么？(针对 3 个协议分别给出解答）
> 2. 如果对上述三个协议，超时时间比 5RTT 长得多，那么哪个协议将在最短的时间间隔内成功交付 5 个报文段？

1. GBN 协议：
	1. A：发送 1，2，3，4，5 号报文段，重传 2，3，4，5。故总共发送了 9 个报文段
	2. B：由于 2 丢失，接收 1，3，4，5 报文时均发送 ACK 1，然后收到重传时依次发送 ACK 2，ACK 3，ACK 4， ACK 5。共 8 个
2. SR 协议：
	1. A：发送 1，2，3，4，5 号报文段，然后重传 2。共 6 个
	2. B：发送 ACK 1，ACK 3，ACK 4， ACK 5，然后发送 ACK 2。共 5 个
3. TCP 协议：
	1. A：发送 1，2，3，4，5 号报文段，然后重传 2。共 6 个
	2. B：由于 2 丢失，接收 1，3，4，5 报文时均发送 ACK 2，然后发送 ACK 6
4. TCP 协议。TCP 有快速重传机制。在第 4 个 RTT 结束时，收到三个冗余 ACK 2，此时触发快速重传，重发 2 号分组

> （同书 P46 题）假设 A、B 两个端系统通过唯一的一条 8Mbps 链路连接（M=10^6），该链路的双向传播时延是 150ms；A 通过一个 TCP 连接向 B 发送一个大文件，B 的接收缓存足够大，每个 TCP 段最大段长度（MSS）为 1500 字节，TCP 采用 Reno 版本，且总是处于拥塞避免阶段（即忽略慢启动）。请回答下列问题：
> 1. 该 TCP 连接能够获得的最大窗口尺寸（以 TCP 段数计）是多少？
> 2. 该 TCP 连接的平均窗口尺寸（以 TCP 段数计）和平均吞吐量（以 bps 计）是多少？
> 3. 该 TCP 连接的拥塞窗口从发生丢包到恢复到最大窗口尺寸要经历多长时间？

1. 最大窗口即丢包前的窗口，发送速率为 $W\times MSS/RTT$，由 $\text{W}\times MSS/RTT=8 \text{Mbps}$，得 $W=100$
2. 平均窗口尺寸 $W_1=0.75W=75$，平均吞吐量为 $W_1\times MSS/RTT=6\text{Mbps}$
3. W 从 50 到 100，共 50 个 RTT
