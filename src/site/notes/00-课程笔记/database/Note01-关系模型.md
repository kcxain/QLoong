---
{"dg-publish":true,"permalink":"/00-课程笔记/database/Note01-关系模型/","title":"Note01- 关系模型与形式化查询语言"}
---


# Note01- 关系模型与形式化查询语言

形象来说，一个关系就一个 Table，关系模型用来处理 Table，它由三个部分组成：

- 描述 DB 各种数据的基本结构形式（关系）
- 描述 Table 与 Table 之间所可能发生的各种操作（关系运算）
- 描述这些操作所应遵循的约束条件（完整性约束）

## 关系的数据结构

关系数据库由表构成，每个表有唯一的名字，称之为关系 (Relation)

### 若干概念

- 元组 (tuple)
  - 关系表的行
  - 关系是元组的集合以元组在关系中出现的顺序无关紧要
- 属性 (attribute)
  - 关系表的列
  - 列的顺序也无关紧要
- 域 (domain)
  - 每个属性所有可能取值的集合
  - 原子域：域中每个元素不可再分
  - 复合域：原子域的组合
  - 空值：表示值未知或不存在

由此可以得到关系的数学定义：

:::tip 定义

设 $A_1,A_2,\cdots A_n$ 是值域为 $D_1,D_2,\cdots, D_n$ 的 $n$ 个属性。具有属性 $A_1,A_2,\cdots,A_n$ 的关系 $R$ 是一个元组集合，其中，每个元组是一个映射的集合 $\{\{A_1\}\rightarrow D_1,\cdots,\{A_n\}\rightarrow D_n\}$

:::

### 性质

- 列是同质的
  - 每一列中的分量是同一类型的数据，来自同一个域
- 不同的列可出自同一个域
- 任意两个元组不能完全相同
- 分量必须取原子值

### 关系模式

我们把一个关系模式定义为：

- $R(U,D,DOM,I,F)$：
  - $R$：关系名
  - $U$：$R$ 的属性集合 $\{A_1,A_2,\cdots,A_n\}$
  - $D$：$U$ 中属性的域集合 $\{D_1,D_2,\cdots,D_n\}$
  - $DOM$：$U$ 到 $D$ 的映射，表明每个属性取什么
  - $I$：完整性约束集合
  - $F$：属性间的函数依赖关系

关系模式也可以简记为 $R(U)$

## 完整性约束

### 若干概念

- 超码
  - 一个或多个属性的集合，这些属性的组合可以在一个关系中唯一地标识一个元组
- 候选码
  - 首先是一个超码，然后它的任意真子集都不是超码。即能标识一个元组的最小集合
- 主码
  - 被设计者**人为选中**的候选码
  - 主码应该选那些值从不或极少变化的属性
  - 一个关系模式只能有一个主码
- 主属性
  - 主码中的属性
- 外码
  - 一个关系模式 $r_1$ 可能在它的属性中包括另一个关系模式 $r_2$ 的主码, 这个属性集合在 $r_1$ 上称作参
    照 $r_2$ 的外码

### 完整性约束分类

- 实体完整性约束
  - 如果 $A$ 是关系模式 $R(U)$ 的主属性，则 $A$ 不能取空值
- 参照完整性约束
  - 要求在参照关系中任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值
  - 即：设 $X$ 是关系模式 $R(U)$ 关于关系模式 $S(U')$ 的外码。如果 $R(U)$ 的关系实例的一个元组在这个属性上取值为 $x$，则 $S(U')$ 实例也必定存在在这个属性上取值为 $x$ 的元组
- 用户定义完整性

## 关系运算

![](https://kkcx.oss-cn-beijing.aliyuncs.com/img/image-20230523151020263.png)

### 关系代数

过程化查询语言。包括一个运算集合，这些运算的输入为若干个**关系**，输出为一个新的**关系**

基本运算：

- 选择：$\sigma$
  - $\sigma_p(R)=\{t|t \in R\  \text{and} \ p(t)\}$
  - $p$ 为选择谓词，是对属性进行的逻辑选择。如 $\sigma_{A=B\wedge D>5}$ 表示 $A$ 属性和 $B$ 属性取值相同，且 $D$ 属性取值大于 5 的元组集合
- 投影：$\Pi$

  - $\Pi_{A_1,A_2,\cdots,A_k}(R)$
  - 返回的关系为选中的这 $k$ 个列，同时，要删去重复元组
- 并：$\cup$

  - $R\cup S=\{t|t\in R \ \text{or} \ t \in R\}$
  - 我们必须保证做并运算的关系**相容**
    - 属性个数相同
    - 两个关系对应属性的域相同
- 差：$-$

  - $R-S=\{t|t\in R\ \text{and}\ t \notin S\}$
  - 关系也必须相容
- 笛卡尔积：$\times$

  - $R\times S=\{tq|t\in R \ \text{and} \ q \in S\}$

:::caution 注意

在笛卡尔积运算中，关系 $R$ 和 $S$ 的属性是不能相交的，如果关系 $R$ 和 $S$ 的属性相交，则需要进行重命名

:::

- 更名：$\rho$

  - $\rho_{S(A_1,A-2,\cdots A_n)}(R)$
  - 表示将关系 $R$ 重新命名为 $S$，且 $S$ 的各个属性按从左到右顺序分别命名为 $A_1,A_2,\cdots ,A_n$
- 交：$R\cap S$

  - $R\cap S=\{t| t\in R \ \text{and} \ t \in S\}$
  - $R\cap S=R - (R - S)$
- 自然连接：$\Join$

  - $R\Join S=\Pi_{U_R\cup U_S}(\sigma_{R.A_1=S.A_1\wedge\cdots R.A_n=S.A_n}(R\times S)$
  - 对有重复属性的两个关系做笛卡尔积，要求在所有相同属性上的值一致
- $\theta$ 连接

  - $R\Join_C S=\sigma_C(R\times S)$
  - $C$ 为两关系属性的限制
- 外连接

  - 左外连接：⟕
    - 取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性
    - 再把所产生的元组加到自然连接的结果中
  - 右外连接：⟖
    - 取出右侧关系中所有与左侧关系的任一元组都不匹配的元组，用空值填充所有来自左侧关系的属性
    - 再把所产生的元组加到自然连接的结果中
  - 全外连接：⟗
    - 左外连接与右外连接的并

### 元组关系演算

非过程化的查询语句

:::tip 定义

$$
\{t|P(t)\}
$$

- 是所有使得公式 $P$ 为真的元组 $t$ 的集合
- $t$ 表示元组变量，$t[A]$ 表示元组 $t$ 在 $A$ 属性上的取值

:::

如，给定下列关系：

```bash
branch (branch_name, branch_city, assets)
customer (c_name, c_street, c_city)
account (account_number, branch_name, balance)
loan (loan_number, branch_name, amount)
depositor (c_name, account_number)
borrower (c_name, loan_number)
```

- 查询所有贷款额度超过 1200 的贷款号、银行名、贷款额度：$\{t|t\in loan \wedge t[amount]>1200\}$

### 域演算

使用从属性域中取值的域变量，而不是整个元组的值

:::tip 定义

$$
\{<x_1,x_2,\cdots,x_n>|P(x_1,x_2,\cdots ,x_n)\}
$$

- $x_1,x_2,\cdots,x_n$ 分别是域变量
- $P$ 是由原子公式构成的公式
- 查询结果是所有包含 $<x_1,x_2,\cdots,x_n>$ 的元组，并且 $<x_1,x_2,\cdots,x_n>$ 使得公式 $P(x_1,\cdots,x_n)$ 为真

:::

还是如上面的例子：

- 查询所有贷款额度超过 1200 的贷款号、银行名、贷款额度：$\{<l,b,a>|<l,b,a>\in loan \wedge a > 1200\}$
- 查询至少有一支贷款额度超过 1200 的客户姓名：$\{<c>|\exists l,b,a(<c,l>\in borrower \wedge <l,b,a>\in loan \wedge a > 1200)\}$

### 关系运算的安全性

如果一个关系运算系统不产生无限关系和无穷验证, 则这个运算是安全的

:::caution 元组关系和域关系演算不安全

关系代数系统是安全的，而元组关系演算和域关系演算系统不安全，如：

- 元组关系演算 $\{t|t\notin \text{EMPLOYEE}(t)\}$ 是无限集合
- 域关系演算 $\{<t_1,t_2>|<t_1,t_2>\in R \vee t_2 > 9\}$ 是无限集合

:::
